// locators/webFormLocators.ts
export const webFormLocators = {
  fields: [
    {
      name: 'First Name',
      inputLocator: '#firstName',
      errorLocator: '#firstNameError',
      validValue: 'John',
      invalidValue: '', // for required
      expectedErrorRequired: 'First Name is required',
      expectedErrorInvalid: 'First Name must be a string', // if applicable
    },
    {
      name: 'Age',
      inputLocator: '#age',
      errorLocator: '#ageError',
      validValue: '25',
      invalidValue: 'abc',
      expectedErrorRequired: 'Age is required',
      expectedErrorInvalid: 'Age must be a number',
    },
    // add other fields similarly...
  ]
};


// pages/webFormPage.ts
import { webFormLocators } from '../locators/webFormLocators';

export class WebFormPage {
  async open() {
    await browser.url('/webform'); // adjust route
  }

  async submitForm() {
    await $('#submitBtn').click(); // update if different
  }

  async fillField(locator: string, value: string) {
    const element = await $(locator);
    await element.setValue('');
    await element.setValue(value);
  }

  async getError(locator: string): Promise<string> {
    const errorEl = await $(locator);
    return errorEl.getText();
  }
}


// specs/formValidation.spec.ts
import { expect } from 'chai';
import { WebFormPage } from '../pages/webFormPage';
import { webFormLocators } from '../locators/webFormLocators';

describe('Web Form Validation Tests', () => {
  const formPage = new WebFormPage();

  it('should validate all error messages dynamically', async () => {
    await formPage.open();

    // Step 1: Submit empty form
    await formPage.submitForm();

    for (const field of webFormLocators.fields) {
      const actualError = await formPage.getError(field.errorLocator);
      expect(actualError).to.equal(field.expectedErrorRequired, `Expected required error for ${field.name}`);
    }

    // Step 2 & 3: Iterate each field to test valid and invalid cases
    for (let i = 0; i < webFormLocators.fields.length; i++) {
      const currentField = webFormLocators.fields[i];

      // Fill current field with valid input
      await formPage.fillField(currentField.inputLocator, currentField.validValue);
      await formPage.submitForm();

      // Assert error message gone for this field
      const error = await formPage.getError(currentField.errorLocator);
      expect(error).to.be.empty;

      // Assert others still show required error
      for (let j = 0; j < webFormLocators.fields.length; j++) {
        if (j !== i) {
          const field = webFormLocators.fields[j];
          const error = await formPage.getError(field.errorLocator);
          expect(error).to.equal(field.expectedErrorRequired, `Expected required error for ${field.name}`);
        }
      }

      // Step 4: Test invalid input for that field (if any)
      if (currentField.invalidValue && currentField.expectedErrorInvalid) {
        await formPage.fillField(currentField.inputLocator, currentField.invalidValue);
        await formPage.submitForm();
        const invalidError = await formPage.getError(currentField.errorLocator);
        expect(invalidError).to.equal(currentField.expectedErrorInvalid, `Expected invalid input error for ${currentField.name}`);
      }

      // Optional: Clear field again if needed or reload page
    }
  });
});


type FieldLocator = {
  name: string;
  inputLocator: string;
  errorLocator: string;
  expectedErrorRequired: string;
};

export class FormFieldUtils {
  private fields: FieldLocator[];

  constructor(fields: FieldLocator[]) {
    this.fields = fields;
  }

  getFieldDataByName(fieldName: string): FieldLocator {
    const field = this.fields.find(f => f.name === fieldName);
    if (!field) throw new Error(`Field "${fieldName}" not found`);
    return field;
  }

  getInputLocator(fieldName: string): string {
    return this.getFieldDataByName(fieldName).inputLocator;
  }

  getErrorLocator(fieldName: string): string {
    return this.getFieldDataByName(fieldName).errorLocator;
  }

  getExpectedError(fieldName: string): string {
    return this.getFieldDataByName(fieldName).expectedErrorRequired;
  }

  getAllFields(): FieldLocator[] {
    return this.fields;
  }
}

